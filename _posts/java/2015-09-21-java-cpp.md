---
layout: post
title: Java VS C++
category: java
comments: false
---
## [一个C++老鸟眼中的 C++ VS Java](http://bbs.51cto.com/thread-189024-1.html)

C++和java都是很棒的语言，套用一句李连杰的话就是：

语言本身没有优劣之分，但程序员有强弱之别。

1、在内存管理方面

在这方面我更欣赏java，也认为这是java比C++更易用的重要原因。C++的用户自己管理
内存和灵活的指针用法往往让用户为了一个内存问题而调试好几天。让用户自己释放内
存使得用户必须非常小心，在程序有多个出口或指针被多个线程或被多个容器拥有的情
况下，何时能安全的释放内存都必须非常谨慎的，而且还要保证在程序的各个出口都保
证不内存泄露，这简直就是噩梦！智能指针能解决一些问题，但他带来的问题同样很多
。java的自动垃圾收集简直就是一大解脱！

2、在多线程编程方面

多线程编程大大增加错误的随机性和破坏了接口的“抽象”，要在C++中设计好一个多线
程程序往往不是件轻松的事情。所以我更欣赏linux/unix下以多进程为主的编程手法。
java用“同步方法”来解决同步问题使得多线程异常简单（相对于C++），但在多线程方
面我更喜欢C++，因为java的方法虽然简单，但太过小儿科了，带来了两大弊端：

1）java采用了锁住整个对象的粗粒度多线程同步控制，而C++可以用更细粒度进行控制
。java采用的方法是这样的：类A，类中有成员变量m1、m2，为了保护成员变量，将类A
中所有访问这两个成员变量的成员函数设为synchronized，当某个线程T1调用了类A对象
（记为obj）的synchronized方法时线程T1将锁住整个对象obj，此时若另外一个线程T2
调用obj的synchronized方法（不一定和T1调用的那个方法是同一个方法）将阻塞（若T
2调用了obj的非synchronized方法不会被阻塞），直到T1调用完synchronized方法为止
。这种锁住整个对象的做法显然简化了实现，控制不够精细。例如，若T1调用了obj的一
个只访问m1不访问m2的方法，由于T1锁住了整个对象obj，导致了T2若调用obj的只访问
m2而不访问m1的方法也会阻塞，这显然不合理的。而且能造成重大的性能损失。

2）java采用锁住对象的方法来实现同步在很多情况下也不合理。因为要同步的资源往往
不是类的私有成员。如我们要同步的资源是某个文件A，在C++情况下，给A配把“锁”即
可，而java会锁住访问文件A的对象，这就要求所有线程都只能创建一个对象供所有线程
共享使用，否则不同的对象就可以同时访问文件A了，同步防护失去了意义。这就带来很
大的不便，需要程序员自己注意不要在别的线程中也new出一个对象来。

3、在网络编程方面

在这方面我更喜欢java，java不愧是靠网络起家，网络编程在java下特别简单。而用C+
+来写网络程序实在是太麻烦了。
