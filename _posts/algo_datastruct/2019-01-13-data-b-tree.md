---
layout: post
title: 红黑树、B树、B-树和B+树
category: data_struct
comments: false
---

## 一、B树
即二叉搜索树（BST, binary search tree）：

- 1.所有非叶子结点至多拥有两个儿子（Left和Right）；
- 2.所有结点存储一个关键字；
- 3.非叶子结点的左指针指向小于其关键字的子树，右指针指向大于其关键字的子树；

## 二、B-树

是一种多路搜索树（并不是二叉的）：  

- 1.定义任意非叶子结点最多只有M个儿子；且M>2；
- 2.根结点的儿子数为[2, M]；
- 3.**除根结点以外的非叶子结点的儿子数为[M/2, M]**；
- 4.每个结点存放至少M/2-1（取上整）和至多M-1个关键字；（至少2个关键字）
- 5.非叶子结点的关键字个数=指向儿子的指针个数-1；
- 6.非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] < K[i+1]；
- 7.非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树；
- 8.所有叶子结点位于同一层；

![b-tree](/images/201901/b-.JPG)

 B-树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点；

 B-树的特性：

- 1.关键字集合分布在整颗树中；
- 2.任何一个关键字出现且只出现在一个结点中；
- 3.搜索有可能在非叶子结点结束；
- 4.其搜索性能等价于在关键字全集内做一次二分查找；
- 5.自动层次控制；

由于限制了除根结点以外的非叶子结点，至少含有M/2个儿子，确保了结点的至少利用率,所以B-树的性能总是等价于二分查找（与M值无关），也就没有B树平衡的问题；

由于M/2的限制，在插入结点时，如果结点已满，需要将结点分裂为两个各占M/2的结点；删除结点时，需将两个不足M/2的兄弟结点合并；

## 三、B+树

B+树是B-树的变体，也是一种多路搜索树。其定义基本与B-树同，除了：
- 1.非叶子结点的子树指针与关键字个数相同；
- 2.非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树（B-树是开区间）；
- 3.为所有叶子结点增加一个链指针；
- 4.**所有关键字都在叶子结点出现**(非叶子节点不存储数据）；

![b+tree](/images/201901/B+.JPG)

 B+的搜索与B-树也基本相同，区别是B+树只有达到叶子结点才命中（B-树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找；

B+的特性：

- 1.所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的；
- 2.不可能在非叶子结点命中；
- 3.非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；
- 4.更适合文件索引系统；

## 四、红黑树
红黑树（Red-Black Tree）是二叉搜索树（Binary Search Tree）的一种改进。我们知道二叉搜索树在最坏的情况下可能会变成一个链表（当所有节点按从小到大的顺序依次插入后）。而红黑树在每一次插入或删除节点之后都会花O（log N）的时间来对树的结构作修改，以保持树的平衡。也就是说，红黑树的查找方法与二叉搜索树完全一样；插入和删除节点的的方法前半部分节与二叉搜索树完全一样，而后半部分添加了一些修改树的结构的操作。
  
红黑树的每个节点上的属性除了有一个key、3个指针：parent、lchild、rchild以外，还多了一个属性：color。它只能是两种颜色：红或黑。

而红黑树除了具有二叉搜索树的所有性质之外，还具有以下4点性质：
- 1.根节点是黑色的。
- 2.空节点是黑色的（红黑树中，根节点的parent以及所有叶节点lchild、rchild都不指向NULL，而是指向一个定义好的空节点）。
- 3.红色节点的父、左子、右子节点都是黑色。
- 4.**每条路径都包含相同的黑节点.**在任何一棵子树中，每一条从根节点向下走到空节点的路径上包含的黑色节点数量都相同。

它是一种弱平衡二叉树(由于是若平衡,可以推出,相同的节点情况下,AVL树的高度低于红黑树),相对于要求严格的AVL树来说,它的旋转次数变少,所以对于搜索,插入,删除操作多的情况下,我们就用红黑树.

## 五、比较和应用

### 5.1 为什么说B+tree比B树更适合实际应用中操作系统的文件索引和数据索引?　
- B+-tree的内部节点并没有指向关键字具体信息的指针,因此其内部节点相对B树更小,如果把所有同一内部节点的关键字存放在同一盘块中,那么盘块所能容纳的关键字数量也越多,一次性读入内存的需要查找的关键字也就越多,相对IO读写次数就降低了.(树高很重要)
- 由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。 
- B+树只需要去遍历叶子节点就可以实现整棵树的遍历.而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作（或者说效率太低）.

### 5.2 红黑树和B树
- 红黑树多用在内部排序，即全放在内存中的，微软STL的map和set的内部实现就是红黑树。
- B树多用在内存里放不下，大部分数据存储在外存上时。因为B树层数少，因此可以确保每次操作，读取磁盘的次数尽可能的少。

java8里的CHM用到了红黑树；mysql里的索引用到了B+树。

## REF
> [B树，B-树，B*树，B+和红黑树的区别](https://blog.csdn.net/Beyond_2016/article/details/81202511)
