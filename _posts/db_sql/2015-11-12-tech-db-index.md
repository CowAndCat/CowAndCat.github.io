---
layout: post
title: 数据库中的索引
category: sql
comments: false
---
索引是对数据库表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息。
##1、为什么要创建索引呢？
这是因为，创建索引可以大大提高系统的性能。   

- 第一，通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。
- 第二，可以大大加快数据的检索速度，这也是创建索引的最主要的原因。
- 第三，可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。
- 第四，在使用分组和排序 子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。
- 第五，通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。

虽然，索引有许多优点， 但是，为表中的每一个列都增加索引，是非常不明智的。这是因为，增加索引也有许多不利的一个方面。

- 第一，创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。 当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。
- 第二，索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。


##2、选择列建立索引

一般来说，应该在这些列上创建索引，例如：

- 在经常需要搜索的列上，可以加快搜索的速度；
- 在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构；
- 在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度；
- 在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的；
- 在经常需要排序的列上创 建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；
- 在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。


同样，对于有些列不应该创建索引。一般来说，不应该创建索引的的这些列具有下列特点：

- 第一，对于那些**在查询中很少使用或者参考的列**不应该创建索引。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。
- 第二，对于那些**只有很少数据值的列**也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。
- 第三，对于那些**定义为text, image和bit数据类型的列**不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。
- 第四，当**修改性能远远大于检索性能**时，不应该创建索引。这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因 此，当修改性能远远大于检索性能时，不应该创建索引。
- 第五，含有null的列通常不建立索引。尽量避免NULL：应该指定列为NOT NULL，除非你想存储NULL。在MySQL中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值。

##3、怎么建立索引
创建索引有多种方法，这些方法包括**直接创建索引**的方法和**间接创建索引**的方法。

- 直接创建索引，例如使用CREATE INDEX语句或者使用创建索引向导；
- 间接创建索引，例如在表中定义主键约束或者唯一性键约束时，同时也创建了索引。

虽然，这两种方法都可以创建索引，但是，它们创建索引的具体内容是有区别的。

使用CREATE INDEX语句或者使用创建索引向导来创建索引，这是最基本的索引创建方式，并且这种方法最**具有柔性**，可以定制创建出符合自己需要的索引。在使用这种方式创建索引时，可以使用许多选项，例如指定数据页的充满度、进行排序、整理统计信息等，这样**可以优化索引**。  
使用这种方法，可以指定索引的类型、唯一性和复合性，也就是说，既可以创建聚簇索引，也可以创建非聚簇索引，既可以在一个列上创建索引，也可以在两个或者两个以上的列上创建索引。


通过定义主键约束或者唯一性键约束，也可以间接创建索引。主键约束是一种保持数据完整性的逻辑，它限制表中的记录有相同的主键记录。在创建主键约束时，系统自动创建了一个唯一性的聚簇索引。虽然，在逻辑上，主键约束是一种重要的结构，但是，在物理结构上，与主键约束相对应的结构是唯一性的聚簇索引。换句话说，在物理实现上，不存在主键约束，而只存在唯一性的聚簇索引。同样，在创建唯一性键约束时，也同时创建了索引，这种索引则是唯一性的非聚簇索引。因此，当使用约束创建索引时，索引的类型和特征基本上都已经确定了，**由用户定制的余地比较小**。

当在表上定义主键或者唯一性键约束时，如果表中已经有了使用CREATE INDEX语句创建的标准索引时，那么主键约束或者唯一性键约束创建的索引**覆盖**以前创建的标准索引。也就是说，**主键约束或者唯一性键约束创建的索引的优先级高于使用CREATE INDEX语句创建的索引。**



##4、索引的特征
索引有两个特征，即唯一性索引和复合索引。

**唯一性索引保证在索引列中的全部数据是唯一的，不会包含冗余数据**。如果表中已经有一个主键约束或者唯一性键约束，那么当创建表或者修改表时，SQL Server自动创建一个唯一性索引。然而，如果必须保证唯一性，那么应该创建主键约束或者唯一性键约束，而不是创建一个唯一性索引。

当创建唯一性索引时，应该认真考虑这些规则：

- 当在表中创建主键约束或者唯一性键约束时，SQL Server自动创建一个唯一性索引；如果表中已经包含有数据，那么当创建索引时，SQL Server检查表中已有数据的冗余性；
- 每当使用插入语句插入数据或者使用修改语句修改数据时，SQL Server检查数据的冗余性：如果有冗余值，那么SQL Server取消该语句的执行，并且返回一个错误消息；确保表中的每一行数据都有一个唯一值，这样可以确保每一个实体都可以唯一确认；只能在可以保证实体完整性的列上创建唯一性索引，例如，不能在人事表中的姓名列上创建唯一性索引，因为人们可以有相同的姓名。

		如：CREATE INDEX table_categoryid ON table (category_id);


**复合索引就是一个索引创建在两个列或者多个列上。**在搜索时，当两个或者多个列作为一个关键值时，最好在这些列上创建复合索引。

当创建复合索引时，应该考虑这些规则：

- 最多可以把16个列合并成一个单独的复合索引，构成复合索引的列的总长度不能超过900字节，也就是说复合列的长度不能太长；
- 在复合索引中，所有的列必须来自同一个表中，不能跨表建立复合列；
- 在复合索引中，列的排列顺序是非常重要的，因此要认真排列列的顺序，原则上，应该首先定义最唯一的列，例 如在（COL1，COL2）上的索引与在（COL2，COL1）上的索引是不相同的，因为两个索引的列的顺序不同。  
MySQL仅能对索引最左边的前缀进行有效的查找。例如：
假设存在组合索引it1c1c2(c1,c2)，查询语句select * from t1 where c1=1 and c2=2能够使用该索引。查询语句select * from t1 where c1=1也能够使用该索引。但是，查询语句select * from t1 where c2=2不能够使用该索引，因为没有组合索引的引导列，即，要想使用c2列进行查找，必需出现c1等于某值。
- 为了使查询优化器使用复合索引，查询语句中的WHERE子句必须参考复合索引中第一个列；
- 当表中有多个关键列时，复合索引是非常有用的；
- 使用复合索引可以提高查询性能，减少在一个表中所创建的索引数量。

		如：CREATE INDEX mytable_categoryid_userid ON mytable(category_id,user_id);

##5、索引类别
###5.1
索引分为聚簇索引和非聚簇索引两种

- 聚簇索引是按照数据存放的物理位置为顺序的；聚簇索引能提高多行检索的速度
聚簇索引**保证关键字的值相近的元组存储的物理位置也相同**（所以字符串类型不宜建立聚簇索引，特别是随机字符串，会使得系统进行大量的移动操作），且一个表只能有一个聚簇索引。因为由存储引擎实现索引，所以，并不是所有的引擎都支持聚簇索引。目前，只有solidDB和InnoDB支持。
- 非聚簇索引对于单行的检索很快。  

![1](/images/201511/mysqlIndex.JPG "聚簇索引和非聚簇索引")

###5.2
根据数据库的功能，可以在数据库设计器中创建三种索引：唯一索引、主键索引和聚集索引。(来自百度，但是我没有理解这三种类别，还不如分为普通索引、唯一索引、复合索引和其他索引的好）

- 普通：`CREATE INDEX..`
- 唯一索引是不允许其中任何两行具有相同索引值的索引。(UNIQUE)
```CREATE UNIQUE INDEX indexName ON table(column(length))```
- 复合索引，当主键是多列组合，创建的主键索引就是复合的。
在数据库关系图中为表定义主键将自动创建主键索引，**主键索引是唯一索引的特定类型**。
`ALTER TABLE article ADD INDEX index_titme_time (title(50),time(10))`
- 其他索引，如全文索引。

###5.3 mysql中的索引类型
索引是在存储引擎中实现的，而不是在服务器层中实现的。所以，每种存储引擎的索引都不一定完全相同，并不是所有的存储引擎都支持所有的索引类型。

- B-Tree索引(MyIASM中默认的是BTREE类型)
- Hash索引  
Hash索引有以下一些限制：
(1)由于索引仅包含hash code和记录指针，所以，MySQL不能通过使用索引避免读取记录。但是访问内存中的记录是非常迅速的，不会对性造成太大的影响。
(2)不能使用hash索引排序。
(3)Hash索引不支持键的部分匹配，因为是通过整个索引值来计算hash值的。
(4)Hash索引只支持等值比较，例如使用=，IN( )和<=>。对于WHERE price>100并不能加速查询。
- 空间(R-Tree)索引
MyISAM支持空间索引，主要用于地理空间数据类型，例如GEOMETRY。
- 全文(Full-text)索引
全文索引是MyISAM的一个特殊索引类型，主要用于全文检索。
```CREATE FULLTEXT INDEX index_content ON article(content)
```
不过切记对于大容量的数据表，生成全文索引是一个非常消耗时间非常消耗硬盘空间的做法。

```
	mysql> SELECT id,FROM_UNIXTIME(time) FROM article WHERE a.title='测试标题'
```
给title字段添加一个BTREE索引：
```
mysql> ALTER TABLE article ADD INDEX index_article_title ON title(200);
```

##6、索引优化
- 使用短索引。对串列进行索引，如果可能应该指定一个前缀长度。例如，如果有一个CHAR(255)的列，如果在前10个或20个字符内，多数值是惟一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作。
- 索引列排序
MySQL查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作；尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引。
- like语句操作：
一般情况下不鼓励使用like操作，如果非使用不可，如何使用也是一个问题。like “%aaa%” 不会使用索引而like “aaa%”可以使用索引。
- 不要在列上进行运算
例如：select * from users where YEAR(adddate)<2007，将在每个行上进行运算，这将导致索引失效而进行全表扫描，因此我们可以改成：select * from users where adddate<’2007-01-01′。
