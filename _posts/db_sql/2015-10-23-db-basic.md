---
layout: post
title: 数据库基本知识
category: db
comments: false
---
### 1、事务及ACID

事务是用户程序的执行，对DBMS来说，是一个读写操作的序列。

事务应该具有四个主要特性：  

- 原子性：所有操作要么全部被执行，要么不被执行。
- 一致性：每个单独执行的事务，当它不与其他事务并发执行的情况下，要保证数据库的一致性。
- 隔离性：若干事务交叉执行，用户不需要考虑并发执行的其他事务的影响。事务都是独立的。
- 持久性：一旦通知事务执行成功，那么即便在数据更新存入磁盘之前发生系统故障，事务的处理结构也能永久保存。

### 2、clustered and non-clustered indexes(聚簇索引和非聚簇索引）
聚簇索引：聚簇顺序就是数据的物理存储顺序。  
非聚簇索引：索引顺序与数据物理排列顺序无关。

一个表最多只能有一个聚簇索引。

在SQL server中，索引是通过二叉树的数据结构来描述的，可以这样理解聚簇索引：索引的叶节点就是数据节点，而非聚簇索引的叶节点仍然是索引节点，只不过有一个指针指向对应的数据块。

前者想电话本，按姓氏排列；后者像课本中的索引，有指针（页码）。

### 3、游标和判断是否到最后。
游标用于定位结果集的行。  
通过判断@@FETCH_STATUS，可以判断游标是否到最后（不为0）。

### 4、隔离级别
**一个事务必须与由其他事务进行的资源或数据更改相隔离的程度。**

隔离级别从允许的并发副作用（例如，脏读或虚拟读取）的角度进行描述。

数据库事务的隔离级别有4个，由低到高依次为Read uncommitted、Read committed、Repeatable read、Serializable，当多个事务同时进行时,通过设置隔离级别来处理脏读、不可重复读、幻读事件。

- 脏读 又称**无效数据的读出**，是指在数据库访问中，事务T1将某一值修改，然后事务T2读取该值，此后T1因为某种原因撤销对该值的修改，这就导致了T2所读取到的数据是无效的。（例如：两个并发的事务，“事务A：领导给singo发工资”、“事务B：singo查询工资账户”，事务B读取了事务A尚未提交的数据。）
- 不可重复读:**是指在数据库访问中，一个事务范围内两个相同的查询却返回了不同数据。**一事务对数据进行了更新或删除操作,另一事务两次查询的数据不一致。（例如：不可重复读，两个并发的事务，“事务A：singo消费”、“事务B：singo的老婆网上转账”，事务A事先读取了数据，事务B紧接了更新了数据，并提交了事务，而事务A再次读取该数据时，数据已经发生了改变。）
- 幻像读:**一事务对数据进行了新增操作,另一事务两次查询的数据不一致。**当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，比如这种修改涉及到表中的“全部数据行”。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入“一行新数据”。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样.  
（例如：singo的老婆工作在银行部门，她时常通过银行内部系统查看singo的信用卡消费记录。有一天，她正在查询到singo当月信用卡的总消费金额（select sum(amount) from transaction where month = 本月）为80元，而singo此时正好在外面胡吃海塞后在收银台买单，消费1000元，即新增了一条1000元的消费记录（insert transaction ... ），并提交了事务，随后singo的老婆将singo当月信用卡消费的明细打印到A4纸上，却发现消费总额为1080元，singo的老婆很诧异，以为出现了幻觉，幻读就这样产生了。）
	
![2](/images/201510/isoLevel2.png "隔离级别")

**read uncommitted : 0 未提交读**

- 将查询的隔离级别指定为 0。
- 可以读脏数据
- 读脏数据:一事务对数据进行了增删改,但未提交,有可能回滚,另一事务却读取了未提交的数据

**read committed : 1 已提交读**

- 将查询的隔离级别指定为 1。
- 避免脏读,但可以出现不可重复读和幻读
- **大多数数据库的默认级别就是Read committed，比如Sql Server , Oracle。**
	
**repeatable read : 2 可重复读**

- 将查询的事务隔离级别指定为 2。
- 避免脏读,不可重复读,允许幻像读。
- Mysql的默认隔离级别就是Repeatable read。

**serializable : 3 可序列化**

- 将查询的隔离级别指定为 3。Serializable是最高的事务隔离级别。
- 串行化读，事务只能一个一个执行，避免了脏读、不可重复读、幻读。
- 执行效率慢，性能很低，一般很少使用（我遇到过一种情况，用时是隔离级别1的30倍），使用时慎重。

**SNAPSHOT**　

- 当读取数据时，可以保证读操作读取的行是事务开始时可用的最后提交版本。
- 这意味着这种隔离级别可以保证读取的是已经提交过的数据，并且可以实现可重复读，
- 也能确保不会幻读。不过这种隔离级别使用的不是共享锁，而是行版本控制。
- SQL Server 2005以后的版本支持。

下表显示了不同隔离级别允许的并发副作用。

![1](/images/201510/isoLevel.png "隔离级别")

###5、SQL View

视图是基于 SQL 语句的结果集的可视化的表。

注释：数据库的设计和结构不会受到视图中的函数、where 或 join 语句的影响。

	CREATE VIEW view_name AS
	SELECT column_name(s)
	FROM table_name
	WHERE condition
注释：视图总是显示最近的数据。每当用户查询视图时，数据库引擎通过使用 SQL 语句来重建数据。（所以说View是虚拟的，里面没有真实数据）